# aspz-lab10-11

ТВ-31 Троцюк Андрій

Варіант 17


2.7. Проєкт: Dumb Shell (DumbSH) та 2.8 Запуск dumbsh

Ціль:
Створити просту оболонку, яка запускає команди користувача.

Код:

![image](https://github.com/user-attachments/assets/813d0073-3cb9-495c-a3e4-beffcf3edbcb)

Результат:

![image](https://github.com/user-attachments/assets/4886040b-2525-4f49-9f9e-d11b63e0444c)

У цій частині я реалізував просту командну оболонку — Dumb Shell. Вона читає команди користувача в циклі, створює новий процес за допомогою fork(), а потім у дочірньому процесі виконує команду за допомогою execlp(). Батьківський процес чекає завершення дочірнього через wait(). У разі введення команди exit, оболонка завершується. Цей приклад дозволяє закріпити знання про створення процесів, обробку введення та базову взаємодію між процесами. Оболонка дозволяє запускати стандартні Unix-команди (наприклад, ls, whoami, date) та демонструє базові принципи роботи звичайного інтерпретатора команд у Linux.

2.9. API wait — деталі

#include <sys/wait.h>

int status;
pid_t pid = wait(&status);

if (WIFEXITED(status)) {
    printf("Exited with code %d\n", WEXITSTATUS(status));
}

wait() — чекає на будь-який дочірній процес.


waitpid(pid, ...) — чекає на конкретний PID.


WNOHANG — не блокує, якщо дитина ще не завершилась.

Код:

![image](https://github.com/user-attachments/assets/eca86794-cc24-4f6e-aafe-0ba68c961b4a)

Результат:

![image](https://github.com/user-attachments/assets/871744ee-06c8-4a58-9d62-e007860731e3)

Програма створює один дочірній процес, який завершується з певним кодом (exit(5)). Батьківський процес викликає wait(), щоб дочекатися завершення дочірнього, після чого за допомогою макросів WIFEXITED() і WEXITSTATUS() перевіряє, чи процес завершився коректно і з яким саме кодом. Це завдання ілюструє механізм контролю завершення дочірніх процесів та обробку їхнього статусу завершення.

2.10. Fork Bomb та створення декількох дітей
// НЕ ЗАПУСКАЙТЕ ЦЕ! Це fork bomb!
:(){ :|:& };:

 Це призводить до вичерпання ресурсів.
Приклад створення кількох дітей:
for (int i = 0; i < 3; i++) {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child %d\n", i);
        exit(0);
    }
}
while (wait(NULL) > 0); // чекає всіх

Код:

![image](https://github.com/user-attachments/assets/e4079349-f781-438d-b250-fbacfcba9139)

Результат:

![image](https://github.com/user-attachments/assets/b98c20f0-e9b6-4230-9ad8-86fc2fbf5353)

У цьому завданні створюється кілька (у прикладі — 3) дочірніх процесів у циклі. Кожен з них виводить свій порядковий номер і PID, після чого завершується. Батьківський процес очікує завершення всіх дочірніх процесів за допомогою циклу wait(). Це дозволяє проілюструвати масове створення процесів та керування ними. Також згадується небезпечна конструкція "fork-бомби", яка створює нескінченну кількість процесів і може вивести систему з ладу — її не рекомендовано запускати.

2.11. Варіації wait
wait(NULL); // будь-який дочірній
waitpid(-1, &status, 0); // еквівалент wait
waitpid(pid, &status, 0); // конкретний процес
waitpid(pid, &status, WNOHANG); // не блокує

Код:

![image](https://github.com/user-attachments/assets/997f4d1b-57d2-4cb8-b6b6-3f4fd5368df7)

Результат:

![image](https://github.com/user-attachments/assets/e7d44a1a-00a8-41b7-924d-2414fb73fd00)

У цьому прикладі використовується waitpid() з прапором WNOHANG, який дозволяє виконувати неблокуюче очікування завершення процесу. Дочірній процес засинає на 2 секунди і завершується з кодом 7. Батьківський процес намагається одразу перевірити, чи завершився дочірній, і отримує повідомлення про те, що він ще працює. Після паузи повторюється виклик waitpid() без прапорів, і результат обробляється. Програма демонструє, як за допомогою WNOHANG уникнути блокування основного процесу.

Завдання 17(індивідуальне)

Використайте waitpid() з прапором WNOHANG, щоб не блокувати батьківський процес при очікуванні на завершення дочірнього з затримкою.

Код:

![image](https://github.com/user-attachments/assets/ac743738-d0d8-43b5-9b19-37eaf5fa7fba)

Результат:

![image](https://github.com/user-attachments/assets/7e006123-320a-4e6e-b322-53fba2b9232c)

У цій програмі демонструється використання системного виклику waitpid() з прапором WNOHANG, щоб уникнути блокування батьківського процесу під час очікування завершення дочірнього. Дочірній процес засинає на 5 секунд, після чого завершується з кодом 42. Батьківський процес періодично перевіряє, чи завершився дочірній, не зупиняючи свою роботу. Це дозволяє імітувати реактивну або асинхронну поведінку, корисну у багатозадачних програмах та серверах.





